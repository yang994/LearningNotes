# WhitePay写支付方案

## 前提
  
  + keeper组的元数据已达成共识
  + 挑战结果没有共识
  + keeper组内最多有f个作恶节点，总结点数为3f+1个
  + 合约职责：
    + 用于支付的upkeeping合约有user部署在链上，记录了keeper组成员和peovider成员。
    + 节点可以在合约中查询成员信息和上一次支付的时间。
    + 合约的支付功能可以验证一笔交易是否合法

## 流程

  + 挑战信息  
    ```go
    type chalresult struct{//挑战信息
      pid   //接受挑战的provider
      t     //挑战时间
      s     //挑战空间
    }

    type chalpay struct{//支付结果
      te    //支付区间的结束时间
      pid   //支付对象
    }
    ```
    + keeper对provider发起挑战，provider回复挑战信息，由keeper验证正确后保存在本地

  + 时空值计算  
    时空值`st`由keeper保存的挑战信息计算而来，keeper保存的某provider的挑战信息，按照挑战时间排序有(t1,s1)...(tn,sn),st为在挑战空间在时间上的积分

  + 当前流程  
    + keeper获取挑战信息后，同步给组内所有节点
    + 选主：对keeper组中节点id排序，处于中间位置的keeper设为`leader`用来触发支付过程
    + 计算金额：leader根据保存的支付结果，取上一次支付的结束时间为开始时间`ts`，缺省时间为UNIX时间0，当前时间为结束时间`te`根据本节点保存的在当前时间区间内的挑战信息计算出时空值`st`，由约定的价格将时空值转化为金额`amount`
    + 触发支付：leader由userid获取upkeeping合约对象，调用合约的支付函数，传入支付金额`amount`，被支付节点的id`pid`，leader的私钥`Pk`（用于对这一笔交易签名）
    + 利益分配：被支付的Provider获得金额的90%，剩下10%由keeper组中的keeper平分
    + 同步支付结果：支付完成后，合约返回支付结果（成功or失败）支付成功，leader构建支付结果结果，同步给组内所有节点


## 问题总结

  + 1.如何达成时空值的共识：
    + 前文已写时空值的计算方法，利用时空值触发支付之前，该时空值必须在组内得到共识。
    + keeper可以不挑战，利用其他节点计算的时空值，或者使用保存的元数据估算时空值，如何避免这种情况
  + 2.如何避免重复支付的问题：
    + 组内所有节点都可以调用合约的支付操作，需要避免重复支付
    + 谁来触发：一笔支付需要有一个leader节点触发支付。如何选择leader、leader掉线怎么处理
  + 3.如何分配利益：provider提供存储资源，keeper组参与维护系统需要获得相应报酬，在流程中需要有一个分配利益的规则

## 修改方案

  > 规定：
  >> `st`：时空值
  >> `kid`：节点的id
  >> `T`：每一笔支付的间隔  
  >> `Ti`：一个leader可以发起支付的时间长度
  >> `ts`：一笔支付的开始时间  
  >> `te`：一笔支付的结束时间，以及记录在合约里的上一次支付的时间
  
  + 挑战信息  
    keeper对provider的挑战信息，保存在keeper节点上，用于时空值的计算
    ```go
    type chalresult struct{
        kid         //发起挑战的keeper
        pid         //接受挑战的provider
        t           //挑战时间
        s           //挑战空间
        r           //provider对这次挑战信息的签名，用来验证挑战信息的真实
    }
    ```

  + 支付结果
    支付完成后，keeper保留的支付信息，用于对支付结果的验证
    ```go
    type chalpay struct{
        pid     //被支付的provider
        kids    //参与这次支付的keeper集合
        ts      //此次支付的开始时间
        te      //此次支付的结束时间
        r       //合约对此次支付的签名，用于验证
    }
    ```

  + 1.leader选择：
    + 节点从合约中查询上一次支付的时间te，计算hi=hash(kid,te)，可以得到组内所有节点的h值，获得h的排序{hi}。
    + 针对问题2 leader掉线的情况，设置一个节点可以触发支付的时间长度Ti，排在第i位的节点可以触发支付的时间区间为[te+T+(i-1)Ti,te+T+i*Ti)，节点每隔一段时间从合约中查询上一次支付的信息，根据当前时间可以判断目前的状态：
      + [te,te+T)：上一次支付已经成功，可以计算下一次支付的h
      + [te+T+(i-1)Ti,te+T+i*Ti)：轮到第i个节点触发支付流程
  
  + 2.时空值共识：（针对问题1）
    + 此时，keeper组已选出leader，leader开始进行时空值的共识和触发支付
    + 获得一个交易号`tid`=hash(ts,te,uid,pid,leaderid)
    + 将上一次支付的时间作为本次支付的开始时间`ts`，当前时间作为支付结束时间`te`，leader根据自己保存的挑战信息计算时空值`st`，对st签名`r`，在组内广播(tid,ts,te,pid,uid,r)
    + keeper收到leader的信息，验证leader是否合法(t∈[te+T+(i-1)Ti,te+T+i*Ti))用[ts,te)内的挑战信息计算时空值`st'`，并签名`r'`，回复leader(tid,r')
    + leader收到keeper回复，则将自己的挑战信息进行打包得`CR`，对进行回复的keeper发送(tid,CR,st)
    + keeper收到信息，验证1.CR是否正确；2.st是否由CR计算得出；3.签名r是否正确，若通过验证，认为leader可信。若不通过验证，认为leader不可信，不做回复。
    + 对于可信的leader，keeper验证自己计算的st'与leader计算的st相差在一定范围内，则对st进行签名`r''`对自己的挑战信息打包得`CR'`，回复(tid,CR',st',r'')，若st与st'相差太大，则回复(tid,CR',st',r')
    + leader对于收到的回复信息进行验证（1.CR’是否正确；2.st‘是否由CR计算得出；3.签名r’是否正确）。将可信keeper的(st',r',r'')记录，当收到了至少f+1个r''时，触发支付。
    + 超过一段时间，没有收到足够的r''，则keeper通过收集的CR组，重新计算时空值，签名发送给验证为可信节点的keeper。
    + keeper收到leader发来的信息，对CR进行验证（通过验证的CR数量不小于leader第一次发来的CR），通过后对计算出的时空值进行签名，回复给leader。

  + 3.触发支付：
    + 此时，leader已经获得共识的时空值`st`，和足够的节点签名信息[r1,r2...ri]。leader使用userid获取合约对象，调用合约方法触发支付。传入(st,ts,te,[r1..ri])
    + 合约中检查ts不小于上一次支付的结束时间，若不满足这个条件，返回错误。(防止重复支付 针对问题2)
    + 合约检查签名的数量，需要不小于f+1个签名，对签名进行验证，验证通过则进行支付。
    + 针对问题3：触发支付的金额为amount=f(st)，其中90%分给被支付的provider，剩下10%由提供签名的keeper平分
    + 支付完成后，修改合约中的上一次支付的时间为此次支付时间，对支付结果进行签名，返回支付结果。
    + leader收到支付结果，同步给组内所有节点，keeper收到之后进行验证并保存。

## 可能出现的问题
  
  + 1：节点根据时间来判断目前的leader是谁，节点之间的时间有偏差，可能会导致不一致。如三个节点(k1,k2,k3)，节点记录的时间分别为(t1,t2,t3)，三个时间可能在不同的时间区间内，导致无法选出leader
    + 解决思路：节点之间进行交互可以对时间进行同步；Ti设置大一些，在节点之间时间相差不大的情况下，也可以达成共识
  + 2：keeper组内的所有节点都失效，如n个节点，t>te+T+n*Ti
    + 解决思路：可能是Ti设置的太小导致所有keeper都无法完成支付，也有可能是组内节点都挂掉。
  + 3.leader触发时可能不提供所有收集的r签名，这样，提供了签名的keeper无法分到收益。
    + 解决思路：分钱时，10%分给所有keeper。leader在支付过程中，记录没有通过验证的节点和没有回复的节点，一并传入合约。由合约记录节点的表现，超过某个规则，就将节点从组内剔除。
  