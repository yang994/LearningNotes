# Threshold Signature

---

## Schnorr Signature

- $G$为椭圆曲线上一个点，任选一$d$为私钥值，$P=d*G$为公钥值。​

- 签名流程
  - 任意一信息 $m$，任选一个值 $k$，算得$R = k*G$
  - 计算 $e = hash( x(R) | P | m )$
  - 计算$s = k + e*d$
  - 获取 $r = x(R)$
  - 签名为:$(r, s)$
  
- 验证流程
  - 签名为sig, 公钥pk, 信息$m$
  - 提取 $P = point(pk)$
  - 提取 $r = sig[0:32]$
  - 提取 $s = sig[32:64]$
  - 计算 $e = hash(r | P | m)$
  - 计算 $R = sG - eP$
  - 比较 $x(R) =? r$

---

## Lagrange 插值法

- $f(x) = \sum_{i=0}^{k} a_i*x^i$ 为k次多项式，$a_i$为任选的值,并令$d=a_0$
- 计算：$d_i = f(i),i=1,2,...,n$
- 从$\{1,2,...,n\}$中任选 k+1 个不同的值$\{w_0,w_1,...,w_k\} \equiv B$，计算得到：$L_{w_i} = \prod_{j \in B, j \neq w_i} \frac{j}{j-w_i}, i=0,1,..,k$，则$f(0) = \sum_{i=0}^{k} d_{w_i}*L_{w_i}$，即$a_0 = d=\sum_{i=0}^{k} d_{w_i}*L_{w_i}$

---

## Our Solution

### $(n,k)$ 门限签名方案原理

- n为玩家数，k为门限值。
- n个人对同一信息签名，收到到 k 个签名后聚合的签名无法被验证通过，收到大于 k 个正确的签名后，聚合的签名可以被验证通过。

### 事前准备

- 用户$user$任选一个随机数$d$为私钥值
- 计算验证公钥 $P_{verify}=d*G$，放在合约中，用于验证签名
- 用户$user$先任选$k$个值$a_i, i=1,2..,k，并且令a_0 = d$
- 则得到多项式$f(x) = \sum_{i=0}^{k} a_i*x^i$
- 计算所有玩家的私钥 $d_i = f(i), i=1,2..,n$
- 计算所有玩家的公钥 $P_i = d_i*G, i=1,2..,n$
- 得到的 $(P_i, d_i)，i=1,2..,n$ 为每个玩家各自对应的密钥对。
- 将这n个密钥对分发给n个不同的​keeper，用于生成各自的签名

### 单元签名流程

- $keeper_i$的密钥对为($P_i,d_i$)，签名信息为$m$
- 选随机值$k_i$
- 计算$R_i=k_i*G$
- 计算 $e = hash(  P | m )$
- 计算 $s_i=k_i+e*d_i$
- 提取 $r_i = x(R_i)$
- 签名为 ($r_i,s_i$)

### 单元验证流程

- $keeper_i$的签名为$sig_i$, 公钥$p_i$, 信息$m$
- 提取 $P_i = point(p_i)$
- 提取 $r_i = sig_i[0:32]$
- 提取 $s_i = sig_i[32:64]$
- 计算 $e = hash(P | m)$
- 计算 $R_i = s_i*G - e*P$
- 比较 $x(R_i)$ =? $r_i$

### 聚合签名流程

- 某keeper收到n个玩家中的超过k个签名$sig_i$，消息$m$
- 选择其中的 k+1 个签名，序号为$\{w_0,w_1,...,w_k\} \equiv B$
- 对每个签名$sig_{w_i}$，调用单元验证，以验证其合法性
- 计算k+1个$L_{w_i} = \prod_{j \in B, j \neq w_i} \frac{j}{j-w_i}$
- 提取各签名的r值:$r_{w_i} = sig_{w_i}[0:32]$
- 从$r_{w_i}$计算各个$R_{w_i}:r_{w_i}$本质上是$R_{w_i}$的x坐标，带入曲线函数可以算出y坐标，即得到了$R_{w_i}$
- 提取各签名的s值:$s_{w_i} = sig_{w_i}[32:64]$
- 计算聚合$R = \sum_{i=0}^{k} L_{w_i} * R_{w_i}$
- 计算聚合$s = \sum_{i=0}^{k} L_{w_i} * s_{w_i}$
- 合约中读取聚合公钥$P_{verify}$
- 聚合签名为：$(x(R),s)$
- 聚合签名等价于使用$d$进行签名，用此可以用对应的公钥$P_{verify}$进行验证。

### 聚合签名验证流程

- 由上一步可得，聚合签名为$(x(R),s)$
- 获取合约中保存的公钥$P_{verify}$用于验证签名
- 计算$e=hash(P_{verify}|m)$
- 计算$R=s*G-e*P_{verify}$
- 比较 $x(R) =? r$
- 等同于验证：$s*G =? R + e*P_{verify}$

### 成立原因

- 由Lagrange插值法可知:

    $d=\sum_{i=0}^{k} d_{w_i}*L_{w_i}$ (1)

- 由签名算法可知:

    $s_{w_i}=k_{w_i}+e*d_{w_i}$ (2)

- 由签名的聚合公式可得:

    $s = \sum_{i=0}^{k} L_{w_i} * s_{w_i}$ (3)

- 由曲线的点乘运算可得:

    $R_{w_i}=k_{w_i}*G$ (4)

- 由$R$的聚合算法可得:

    $R = \sum_{i=0}^{k} L_{w_i} * R_{w_i}$ (5)

- 由$P_{verify}$的计算方法可得:

    $P_{verify}==d*G$ (6)

- 从而：

    $$s*G \\
    = \sum_{i=0}^{k} L_{w_i}*s_{w_i} (依据等式(3))\\
    = \sum_{i=0}^{k} L_{w_i}*(k_{w_i} + e*d_{w_i})*G (依据等式(2))\\
    = \sum_{i=0}^{k} L_{w_i}*k_{w_i}*G + \sum_{i=0}^{k} e*d_{w_i}*L_{w_i}*G \\
    = \sum_{i=0}^{k} L_{w_i}*R_{w_i}  + \sum_{i=0}^{k}e*d*G (依据等式(4)和等式(1))\\
    = R + e*P_{verify} (依据等式(5和等式(6))$$
