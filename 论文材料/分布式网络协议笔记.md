## gossip算法

  + 这种算法主要解决的问题：如何将一条信息发送到全网
    + 网络中某节点需要发送一条信息`m`，设定一个数量`k`，该节点将信息随机发给链接的k个节点
    + 网络中节点收到m，同样随机选择k个节点进行信息的发送（不发给发来信息的节点）
  + 这种算法可以保证最终一致性，同步消息有延迟，无法防止节点作恶
  + 扩展性比较强，节点加入和离开网络很简单
  + 在确认节点alive的过程中，这种算法比较好用

## kad-dht

  + 使用大空间的hash方法获得节点id，如SHA1 160位
  + 分布式hash表（DHT）将节点ID和数据hash同构，就是对数据进行hash生成的hash值和节点id的hash值是同样的位数。因为hash的空间很大，所以碰撞概率忽略不计。数据以kv形式保存，key为数据的hash值，value为数据本身
  + 用二叉树的结构，网络中每个节点都是二叉树上的一个叶子节点，将两个节点id做异或操作，可获得节点之间的“距离”
  + 节点按照“自己的视角”对二叉树进行拆分。从根节点开始，将不包含本节点的子树拆分出来，如此循环，最后只剩节点自身。这样拆分的子树个数最多为hash值的位数
  + 拆分完成后，为拆分出来的每一个子树建立一个路由表，路由表的上限设置为K，路由表称为K-Bucket，对每个子树都保存不多于K个节点用于路由，就可以访问到树中的所有节点
  + 新节点A加入，向任何一个节点B建立链接，B将A加入到自己的K桶中，并且向A返回距离A最近的几个节点（使用异或计算）。A收到信息之后，开始构建自己的K桶
