# WritePay 写支付

## 目前时空支付流程
  
  由一组keeper向provider发起挑战，获得挑战结果计算时空值，在某个时间触发支付过程
  
  + 挑战：k1、k2...等 单独向provider发起挑战，获取挑战结果（ti，si），并且向组内所有keeper进行同步
  + 选主：支付之前，通过某种规则选出master节点用来触发支付，目前的规则为以id号排序，选出中间的作为master
  + master根据本节点保存的挑战结果信息，计算时空值st，由uid获取合约对象，传入本节点私钥Pk，时空值st，支付对象pid触发支付
  + 合约用Pk创建auth，由auth发送一笔交易
  + 支付完成返回支付信息给master，master将支付信息广播到组内所有节点。

## 当前流程存在的问题
  
  + 组内节很多时，同步开销可能比较大，有减小的空间
    + 同步的内容包括挑战信息的同步，支付结果同步。
    + 每个节点需要将自己收到的每一条挑战信息广播给组内其他节点，每一条信息的同步开销都为o(n)。
    + 挑战信息用于时空值的计算，修改时空值计算的方案，可以减少挑战信息上的通信开销,如节点用本地有的信息进行计算，汇总所有节点的时空值进行支付。
  + 只要拥有userid和keeper的私钥，组内的所有keeper都可以获得合约对象，调用支付方法，不需要通知其他节点知晓。

## 聚合签名、门限签名

### 签名过程
  + 原材料：数据`m`  私钥`Pk`
  + 导出：公钥`Sk`=t(Pk)  签名`r`=s(m,Pk)
  + 签名者发送（m,r,Sk），验证着收到信息计算等式：`f(r,m,Pk)==0`可以验证数据是否真实

### 签名的聚合

  + 存在多个数据私钥对(m1,Pk1)...(mi,Pki)有(m1,r1,Sk1)...(mi,ri,Ski)
  + 验证`∑f(r,m,Pk)==0`可以转换为`f(∑r,∑m,∑Pk)==0` 则这种签名可以聚合

### 门限值

  组内n个节点，当收到t(t<=n)个以上的签名时，验证才能够通过。t为门限值，门限签名最常用的载体为拉格朗日差值

## 改进方案

  + keeper组中所有keeper分别对provider进行挑战获取挑战结果。(这里认为keeper保存的挑战结果都是从provider获取的正确的信息)
  + 选主方案还没有具体考虑
  + 由master发起支付，向组内所有节点广播支付信息，包括开始时间`ts`结束时间`te`，组内节点keeperi收到后，根据自己保存的挑战信息单独计算时空值sti，签名发送给master`(sti,Pki,ri)`
  + 当master收到2f+1个时空值信息时，聚合`r=(∑sti,∑Pki,∑ri)` 触发合约 传入(r,ts,te)
  + 合约端检查ts是否大于记录中的上一次支付时间，聚合签名是否正确，支付金额、私钥是否正确，验证通过进行支付，支付完成后，返回支付结果
  + master收到支付结果，对数据签名后对组内所有节点进行广播
