# WhitePay写支付方案

## 流程

  + 挑战信息  
    ```go
    type chalresult struct{//挑战信息
      pid   //接受挑战的provider
      t     //挑战时间
      s     //挑战空间
    }

    type chalpay struct{//支付结果
      te    //支付区间的结束时间
      pid   //支付对象
    }
    ```
    + keeper对provider发起挑战，provider回复挑战信息，由keeper验证正确后保存在本地

  + 时空值计算  
    时空值`st`由keeper保存的挑战信息计算而来，keeper保存的某provider的挑战信息，按照挑战时间排序有(t1,s1)...(tn,sn),st为在挑战空间在时间上的积分

  + 当前流程  
    + keeper获取挑战信息后，同步给组内所有节点
    + 选主：对keeper组中节点id排序，处于中间位置的keeper设为`leader`用来触发支付过程
    + 计算金额：leader根据保存的支付结果，取上一次支付的结束时间为开始时间`ts`，缺省时间为UNIX时间0，当前时间为结束时间`te`根据本节点保存的在当前时间区间内的挑战信息计算出时空值`st`，由约定的价格将时空值转化为金额`amount`
    + 触发支付：leader由userid获取upkeeping合约对象，调用合约的支付函数，传入支付金额`amount`，被支付节点的id`pid`，leader的私钥`Pk`（用于对这一笔交易签名）
    + 利益分配：被支付的Provider获得金额的90%，剩下10%由keeper组中的keeper平分
    + 同步支付结果：支付完成后，合约返回支付结果（成功or失败）支付成功，leader构建支付结果结果，同步给组内所有节点

## 问题和解决方案

### 合约职责
  
  + 用于支付的upkeeping合约有user部署在链上，记录了keeper组成员和peovider成员。
  + 合约应记录上一次支付信息，包括支付时间`te`，支付对象`pid`，交易的签名`r` 用于验证。
  + 节点可以在合约中查询成员信息和支付信息。
  + 在支付过程中，keeper触发合约的支付操作进行支付，合约需要验证这笔支付的时间段[ts,te)是否合法，再通过聚合公钥验证这笔交易金额是否是keeper共识的结果。
  + 对于合约来说，一个时间段对一个provider只能有一笔支付，合约不需要参与keeper组的选主过程。

### 利益分配
  
  在系统中，provider提供存储资源，keeper对系统进行管理，时空支付是用户对节点做出的贡献支付报酬的过程。每隔一段时间对provider的工作量进行评估，得出一个支付金额。这笔金额大部分分给provider，剩下部分分给keeper组
  
  __思路1__

  + 触发合约的支付需要额外消耗gas，gas由触发者支付。所以触发支付的节点应该获得更多的报酬
  + provider获得支付金额的90%，leader获得1%，剩下9%由keeper组中的节点平分（包括leader）
  + 对于keeper节点，触发支付是有利可图的，所以会造成节点之间争抢触发支付的情况。
  
  __思路2__
  
  + 组内所有keeper都要参与支付过程，每个节点都有可能进行支付的触发。所以在分配利益时，provider获得90%金额，剩下10%由keeper平分。
  + 这种方法对于keeper节点，是无利可图的，在单次支付中，触发支付的keeper要多花费gas是亏钱的。若1天支付24次，组内6个节点，则每个节点平均一天支付4次，平均每个节点每天花费的gas是一样的，这样也能够保证公平。
  + 因为单次支付亏钱，所以可能导致keeper回避触发支付的情况，解决方案：组内共识的leader没有在规定时间完成支付流程，则交给下一位leader触发，本节点被认为是失效节点，不参与利润分配

### 选主过程

  + 在某个确定的时间段[ts,te)对一个provider进行的支付，需要由一个节点进行触发。需要有一种方法，做到组内每个节点都有触发支付的机会
  + 每隔一段时间，keeper检查一遍自己是否为下一次支付的leader
  + 合约保存上一次支付的时间`ts`，和keeper组的信息。节点将st和本节点id进行hash->h=hash(ts,kid),对所有节点的h进行排序，取值最小的作为下一次支付的leader。
  + 假设支付间隔为1小时，上一次支付时间`ts`则作为leader的节点在ts+1h是应该触发一次支付。设定时间区间为`t`若在ts+1h+t还没有触发支付，则可以认为leader故障，此时选择h排序中第二个节点作为leader开始进行支付流程。第i个keeper可以触发支付的有效时间为[ts+1h+(i-1)t,ts+1h+i*t)。失效的keeper节点不参与此次金额的分配。
  
  + 存在的问题：节点之间时间不一致的问题。
  + 解决方案：用链上时间替代本地时间，上一次支付的时候链上块数作为上一次支付时间`ts`，支付间隔设为`h`个块，有效支付区间设为`t`个块。第i个keeper可以触发支付的有效时间[ts+h+(i-1)t,ts+h+i*t)，失效的keeper不参与此次分配。


### 挑战、时空值计算过程
  
  + keeper组中的所有节点每隔一段一时间对provider分别发起挑战，获得挑战信息，保存在本地

    ```go
    type chalresult struct{//挑战信息
      pid   //接受挑战的provider
      t     //挑战时间
      s     //挑战空间
      proof //此次挑战的证明
    }
    ```

  + 时空值应该在keeper组中达成共识，假设有f个作恶节点的情况下，至少应该有2f+1个节点对时空值做出共识。
  + 总体方法为leader算出一个时空值，组内其他keeper对该时空值做验证。leader收到至少2f+1且有f+1以上的验证通过信息后，就可以触发合约支付。这里，验证节点以自己保存的挑战信息为基础，计算出时空值，与leader传来的时空值作比较，如果在一个范围内，则验证通过，向leader发送通过的签名。
  + 问题，keeper可以不验证，直接给出自己的通过签名以促成支付成功，这样，keeper就可以不挑战，也能收到一笔支付的费用，对于keeper来说能获得更多的利益。需要有一种机制来保证keeper真的根据自己的挑战信息，做出了对时空值的验证。
  + leader从合约中查询上一次支付的时间作为此次支付的开始时间`ts`，以当前时间作为支付的结束时间`te`
  
  + _流程开始_：leader在本地保存的挑战信息中，找出挑战时间在[ts,te)之间的数据，根据上文所写方法计算出时空值`st`
  + 获取一个交易号`tid`=hash(ts,te,pid,leaderid)+round(标识交易，并且注明交当前触发交易的是排序中的第几个keeper)
  + leader对st和交易号签名`r`，将(tid,ts,te,pid,r)广播给同组其他keeper
  + 同组节点keeperi收到leader发来的信息，根据ts、te 由本地保存的挑战信息计算时空值`sti`，进行签名`ri`。回复leader(tid,ri)。
  + leader收到keeperi的回复，发送(tid,st),keeperi收到后，对st进行验证，若与自己计算的sti在一个范围内，(st/10000==sti/10000)则通过验证，对st和交易号进行签名`ri'`回复leader(tid,sti,st,ri')。
  + 若不通过验证，则回复(tid,sti,ri)。leader需要收到至少2f+1个回复，验证sti和ri的正确性，并且多数是对st通过的回复，才可以触发支付。
  
  + 问题1：keeper可以通过使用自己保存的元数据信息来对时空值进行估算，依然不需要对provider进行挑战，能否用零知识证明来解决这个问题
  + 问题2：若leader的时空值计算错误，方案将无法达成共识。
    + 解决方案，做第三轮共识：若leader计算的时空值有误，从收到的时空值信息中找到f+1以上的在一个范围内的时空值(后n位变成0)，将这个值回复给发来签名的keeper，进行收集签名的过程。
    + 若以上方法没有达成共识，则说明keeper组在这个时间区间内无法达成共识。1.leader广播异常信息(tid,err)；2.keeper收到异常信息后，将自己保存的挑战信息打包广播给组内所有节点；3.节点收到2f+1以上节点发来的挑战信息后，开始计算新的时空值。回到流程开始。
    + 当组内节点仅凭自己保留的信息计算的时空值无法达成共识的时候，就需要更加复杂的方法取实现共识，以上方案将组内的挑战信息进行一次全量的同步，使组内节点持有完整的挑战结果信息，更可能得到相同的时空值。
  + 问题3：作为leader的keeper可以不进行挑战，收集f+1个签名就可以触发一次支付，获得触发支付的报酬

### 触发支付过程
  
  + leader收集到对时空值st的签名（r1...rn），触发合约支付操作，传入(tid,ts,te,st,[ r1...rn ])
  + 合约中，验证ts>=上一次支付的时间，验证签名数量大于f+1个，再对签名进行聚合验证，验证通过，则进行支付，根据tid，在keeper分配金额时去掉失效的keeper节点。上述情况不通过，返回错误信息，通过返回支付结果，并且将支付结果记录在合约中。以te作为支付时间，对这次交易进行签名`r`
  + 问题：合约中不需要做选主中的hash计算。可以将失效的keeperid记录在tid中，tid可以达成全组共识。

