# 写支付（Write Pay）

## 场景描述
在去中心化存储系统中，用户（User）将数据交给存储者（Provider），并且向提供服务的Provider支付报酬。与中心化存储不同的是，在这个过程中，无法保证双方的可信。Provider可以向User收取服务费，但是不实际保存数据，User可以要求Provider提供服务，但是设法不支付报酬。
在mefs中，引入第三方维护者（Keeper组）来防止上述情况发生，保证系统的可信。Keeper组由多个独立的节点组成，Keeper组有多种功能，Keeper存储User的元数据；代替User向Provider发起挑战，保证Provider实际保存了User的数据；在有Provider失效时，进行数据的修复。每隔一段时间，Keeper组代表User向Provider进行一次支付，这个过程为写支付，以下重点讨论写支付过程。
支付的内容为Provider在一段时间内提供的存储资源的报酬，报酬由存储空间在时间上的累计值决定，简称时空值。时空值由挑战结果计算得来，每个Keeper节点都会单独对Provider发起定期挑战，记录当前时刻（t）Provider保存的数据量（s）。支付时，Keeper组需要先对这个时间段内的Provider的时空值达成共识，再调用合约中的方法触发支付。

## 问题总结
+ 对时空值达成共识
  + 时空值由Keeper对Provider在一段时间内的挑战信息计算而来，是对Provider工作量的估算，挑战信息由Keeper节点单独向Provider发起挑战获得，每个Keeper保存的同一个Provider的挑战信息可能不一样，因为每个节点发起挑战的时间都不同，但是在保证挑战信息正确的前提下，Keeper根据自身挑战信息算出来的时空值之间的差距不会太大,因为Provider在一段时间内存储的数据量是确定的。从这里出发，对于时空值的计算有两种方法：
    + Keeper将挑战信息进行完全同步，保证所有节点拥有的挑战信息一致的情况下，进行计算；
    + Keeper根据自身节点保存的挑战信息计算之后，进行组内的共识。
  + 前者对于时空值的计算会更加的准确，因为采样点多，但是每条挑战信息都会在组内进行同步，会产生一笔通信开销。后者在不同节点之间计算出的时空值会不同，但是只要Keeper节点定期对Provider进行挑战，拥有规定时间段内较完整的挑战数据，计算出的时空值偏差不会很大。即使再“准确”的时空值，也是对于Provider工作量的估计值，从减小通信开销的角度来考虑，后一种办法应该为首选，在这种办法无法达成共识的情况下，使用更加复杂的前一种办法。
+ 触发合约支付
  + 合约是链上的一段代码，其中的方法可以被节点调用。合约方法由链上的矿工执行，调用者需要支付gas作为矿工消耗的计算资源的报酬，对于支付过程，gas可以理解为一笔支付操作的手续费，合约中执行的操作越复杂，所花费的gas越高，所以合约中的操作应尽可能的简单，以减少gas消耗。这里，需要明确以下两个问题：
    + 支付合约的功能
      + User初始化时，部署在链上的Upkeeping合约，记录了服务于该User的Keeper和Provider。合约中有支付的方法，由keeper调用。为了完成基本的支付流程，需要传入支付金额、支付对象、调用者的私钥（为这笔支付交易签名）。触发支付操作时，合约将支付金额支付给支付对象
      + 能够触发合约支付功能的，只能是合约中的Keeper，所以在支付过程中，需要检查触发者是否为合约内的Keeper
      + 对于Provider支付的时间区间应该是连续且不重叠的，合约中应保存上一次支付的时间，在触发支付时，需要传入此次支付的时间段，开始时间应为上一次支付的时间，结束时间应在上一次支付时间之后。避免重复支付
    + 一次支付操作由谁来触发
